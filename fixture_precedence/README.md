# Fixture Precedence Experiment
This experiment is meant to illustrate the fixture import behavior across a simple sample project to show the order of
fixture resolution precedence when two fixtures of the same name are utilized. The accumulative import behavior of `conftest.py`
files will also be illustrated.

## Directory Structure
Two test modules, two conftest files at different levels from the root test directory (what pytes refers to as the `rootdir`).
```shell
fixture_precedence/
├── conftest.py
├── sub_dir
│   ├── conftest.py
│   └── test_sub_dir.py
│   └── test_sub_dir_local.py
└── test_root.py
```

## Overview

What we find in this experiment is that the inner test module, `test_sub_dir.py` resolves its fixtures from the outer to
innermost level. It can see all fixtures at its own directory level all the way up to the root dir where all found
conftest files get merged together but with precedence assigned at the innermost level.

So the pytest behavior would appear to incrementally load conftest files at all folders starting from the `rootdir` and leading
down to a particular test module, merging and updating any definitions found along the way. The final update for a symbol
must come from the innermost layer, even to the test module itself, overriding any previously seen symbols found earlier in the
upper folder levels. This update behavior is analogous to a python dict's update behavior

```py
dict_obj = {'a':1, 'b':2, 'c':3} # analogous to the rootdir level
dict_obj.update({'d':4, 'a':11}) # 1st conftest file
dict_obj.update({'e':5, 'd':44}) # 2nd conftest file

dict_obj == {'a': 11, 'b': 2, 'c': 3, 'd': 44, 'e': 5} # final result
```

## Test Results

The following is the console output generated by running pytest over the test folder.

```shell
$ pytest fixture_precedence
======================================================= test session starts =======================================================
platform darwin -- Python 3.7.3, pytest-5.0.1, py-1.8.0, pluggy-0.12.0
rootdir: /Users/USERX/pytest_behavior
plugins: openfiles-0.3.2, arraydiff-0.3, doctestplus-0.3.0, cases-2.2.5, remotedata-0.3.1
collected 10 items

fixture_precedence/test_root.py ..FE.                                                                                       [ 50%]
fixture_precedence/sub_dir/test_sub_dir.py ....                                                                             [ 90%]
fixture_precedence/sub_dir/test_sub_dir_local.py F                                                                          [100%]

============================================================= ERRORS ==============================================================
________________________________________________ ERROR at setup of test_inner_fix _________________________________________________
file /Users/USERX/pytest_behavior/fixture_precedence/test_root.py, line 10
  def test_inner_fix(inner_fix):
E       fixture 'inner_fix' not found
>       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, common_fix, doctest_namespace, monkeypatch,
        outer_fix, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory,
        tmpdir, tmpdir_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/USERX/pytest_behavior/fixture_precedence/test_root.py:10
============================================================ FAILURES =============================================================
____________________________________________________ test_common_fix_expect_in ____________________________________________________

common_fix = 'common_out'

    def test_common_fix_expect_in(common_fix):
>       assert common_fix == "common_in"
E       AssertionError: assert 'common_out' == 'common_in'
E         - common_out
E         + common_in

fixture_precedence/test_root.py:8: AssertionError
______________________________________________________ test_common_fix_local ______________________________________________________

common_fix = 'common_local'

    def test_common_fix_local(common_fix):
>       assert common_fix == "common_in"E       AssertionError: assert 'common_local' == 'common_in'
E         - common_local
E         + common_in

fixture_precedence/sub_dir/test_sub_dir_local.py:8: AssertionError
=========================================== 2 failed, 7 passed, 1 error in 0.08 seconds ===========================================
```

## Observations
`fixture_precedence/sub_dir/test_sub_dir.py` passes all of its tests, so all fixtures are visible and match the expected values.
This indicates that `common_fixture` is resolved to the definition in `fixture_precedence/conftest.py`. Furthermore fixtures
defined in `fixture_precedence/sub_dir/conftest.py` and `fixture_precedence/conftest.py` are all visible to the test module as
seen with the usage of the `outer_fix` fixture.

<br>

`fixture_precedence/sub_dir/test_sub_dir_local.py` fails its single test case, showing that the local definition of `common_fixture`
in the test module takes precedence over the conftest definitions.

<br>

Finally `fixture_precedence/test_root.py` fails one test case and errors out on another. The error occurs because the `inner_fix` fixture
is not visible to the `test_root.py`. The failure occurs because the `common_fixture` is resolved to the fixture defined in
`fixture_precedence/conftest.py` which does not match the expected value.

<br><br>

# Relevant documentation

This excerpt from the book *pytest Quick Start Guide* discusses the top level visibility of fixtures to any
test modules that hold a direct path from the conftest's folder down to any subfolder directly beneath it.

> **Sharing fixtures with conftest.py files**
>
> A conftest.py file is a normal Python module, except that it is loaded
> automatically by pytest, and any fixtures defined in it are available to test
> modules in the same directory and below automatically.
> **pytest Quick Start Guide**
> *Bruno Oliveira*

<br>

This excerpt from the online documentation discusses order of fixture resolution, going in reverse order
in the ranking of precedence for fixture discovery.

> **`conftest.py`: sharing fixture functions**
>
> The discovery of fixture functions starts at test classes, then test modules, then conftest.py files
> and finally builtin and third party plugins.
> https://docs.pytest.org/en/stable/fixture.html#conftest-py-sharing-fixture-functions

The most immediate representation of this experiment in the official documentation lands in the first two
examples of fixtures being overridden. This exercise in fixture precedence is essentially the same idea
as overriding fixtures if you start with the understanding that the highest level conftest.py file defines
the most widely visible fixtures, but also the least precedent ones. The closer you get to the test module
the higher the precedence of a fixture to override the more general higher up the folder structure.

> **Overriding fixtures on various levels**
>
> - Override a fixture on a folder (conftest) level
> - Override a fixture on a test module level
> - Override a fixture with direct test parametrization
> - Override a parametrized fixture with non-parametrized one and vice versa
> https://docs.pytest.org/en/stable/fixture.html#overriding-fixtures-on-various-levels

<br>

# Summary
By default fixtures that get resolved on the path from the root directory to test module are resolved closest to the
test module itself. You can think of fixture resolution as accumulative working from the root test directory
all the way down to the test module itself, where subsequent definitions to symbols closer to the test module
override/overwrite/update any definitions found earlier in the path.


```shell
root_test_dir
├── conftest.py                   <-------- Rank 5
└── sub_dir_1
    ├── conftest.py               <-------- Rank 4
    ├── sub_dir_1_1
    │   ├── conftest.py           <-------- Rank 3
    │   └── sub_dir_1_1_1
    │       └── conftest.py       <-------- Rank 2
    │       └── test_module.py    <-------- Rank 1
```
